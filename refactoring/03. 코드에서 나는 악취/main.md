# 03. 코드에서 나는 악취

- 기이한 이름: 이름이 잘 지어지지 못한 함수, 클래스 등의 이름 바꾸기
- 중복 코드: 중복 코드가 있으면 코드의 구조를 변경해서 한곳으로 코드를 모은다. 쉽게 바로 코드를 추출할 수 없는 경우에는 문장 슬라이드하기, 메서드 올리기(서브클래스 중복 코드를 부모로 올리기) 사용.
- 긴 함수: 긴 함수의 경우 함수 추출하기 사용. 추출하기 어려운 구조일 때는 임시 변수를 질의 함수로 변경, 매개변수 객체 사용, 조건문 분해, 다형성 사용, 반복문 쪼개기 사용.
- 긴 매개변수 목록: 안에서는 일부 매개변수를 질의 함수 이용해서 삭제, 그리고 밖에서는 여러 개의 자잘한 매개변수를 하나의 객체로 묶어서 함수로 전달. 매개변수 중 플래그 변수가 있다면 별도의 함수로 분리하고, 여러 함수에서 몇 개의 매개변수를 공통으로 사용한다면 클래스를 만들어서 함수를 클래스로 옮김.
- 전역 데이터: 최대한 전역 데이터를 줄이기 위해 변수를 캡슐화, 유효범위를 최소 크기로 줄임.
- 가변 데이터: 데이터가 최대한 불변성을 유지할 수 있도록 세터의 수를 줄이고, 변수를 더욱 캡슐화하고, 너무 거대한 자료구조는 작은 크기로 나누고, 질의 함수와 변경 함수를 확실히 분리해서 의도하지 않은 데이터 변경을 최대한 막을 수 있게 함.
- 뒤엉킨 변경: 어떤 특정 모듈을 수정하는 이유가 여러 개일 때는, 모듈을 수정하는 이유가 하나가 되도록 관심사 기준으로 모듈 코드 재편성.
- 산탄총 수술: 어떤 특정 기능 구현을 위해 이 모듈 저 모듈 다 수정해야 하는 구조일 때, 관심사 기준으로 모듈 코드를 모아서 한 곳만 수정해도 기능을 구현할 수 있는 구조로 만듦.
- 기능 편애: 원래 모듈은 서로 간 독립성을 유지하는 게 좋음(낮은 결합도). 어떤 함수가 다른 어떤 모듈의 함수 여러 개를 호출하고 있다면, 모듈 안으로 함수를 옮기거나, 아니면 통째로는 못 옮기는 경우에는 함수를 쪼갠 다음에 옮긴다.
- 데이터 뭉치: 어떤 클래스의 여러 데이터 필드 중 일부 몇 개 필드가 항상 동시에 사용되는 느낌이 있을 때는 그 필드들을 묶어서 별도의 객체로 만들면 좋음. 예를 들어 만약 클래스에 여러 개의 데이터 필드가 있고 그 여러 개 중에 좌표 값으로 x 값과 y 값이 있다면, 좌표 값을 따로따로 저장하지 말고 좌표 보관을 위한 클래스를 별도로 만들면 됨.
- 기본형 집착: 전화번호나 금액처럼 단순히 문자열 같은 기본형으로 저장, 표현할 수도 있지만 그보다 클래스를 만들어서 데이터를 보관하면 더 많은 정보를 담거나 표현 방법이 다양해진다면 기본형을 버리고 클래스를 사용한다.
- 반복되는 switch문: 무조건 switch문을 다형성으로 바꿔 줘야 하는 것은 아니지만, switch문이 여러 개이고 모두 어떤 데이터의 종류를 기준으로 처리 로직을 분기한 형태라면 다형성으로 바꾸는 것이 좋음.
- 반복문: 가독성을 위해 반복문을 filter, map 등 파이프라인 함수로 변경.
- 성의 없는 요소: 함수, 클래스, 인터페이스 등 프로그래밍 언어의 기본 '요소'를 사용했지만 사실 그 요소를 사용해서 코드를 구현하지 않아도 되는 경우에는 그런 불필요한 부분을 없애는 리팩터링을 수행. 예를 들어 어떤 클래스가 있는데 클래스에 함수가 하나밖에 없고 굳이 따로 클래스로 떨어져 있을 필요가 없을 때에는 클래스를 없애고 함수 위치를 변경함.
- 추측성 일반화: 나중에 필요할 수도 있다는 생각에 별도로 만들어 놓은 함수, 클래스, 인터페이스 등은 당장 필요 없는 것이라면 삭제, 인라인화하는 것이 좋음.
- 임시 필드: 클래스의 여러 필드 중 항상 값이 들어가는 것이 아니라 어떨 때는 null값이 되는 필드는 코드를 이해하기 어렵게 하므로, 그런 필드들은 따로 모아서 별도의 클래스로 옮김.
- 메시지 체인: 어떤 객체의 데이터를 가져오기 위해 프로퍼티의 프로퍼티의 프로퍼티를 타고 내려가야 하는 구조일 때에는 너무 깊숙이 밑으로 내려가지 않아도 필요한 데이터를 가져올 수 있게 위 수준에서 중개 프로퍼티(지름길)를 만들어 줌. ex. `person.department.manager.name` -> `person.managerName`으로 줄임.
- 중개자: 어떤 클래스가 제공하는 기능들이 대부분 다른 클래스의 기능을 하나 호출해서 결과를 반환하는 식이라면 앞의 클래스를 제거하고 뒤에 클래스를 바로 사용할 수 있게 변경.
- 내부자 거래: 클래스 간 결합도가 너무 높을 때에는, 결합되는 부분을 별도의 함수로 빼내거나, 제3의 중간자 모듈을 만들어서 두 모듈 간의 소통을 중간자를 통하게끔 변경하거나, 부모/자식 클래스 간 결합도의 경우 상속 구조를 위임 구조(함수를 호출하는 방식)로 변경.
- 거대한 클래스: 거대한 클래스를 쪼갤 때는 유사 기능별로 묶어서 클래스를 추출하거나, 타입별 코드가 있는 클래스의 경우 타입별 코드를 각각의 서브클래스로 만들어 줌.
- 서로 다른 인터페이스의 대안 클래스들: 여러 클래스 간 선택해서 기능을 이용할 수 있도록 최대한 클래스의 인터페이스를 가능한 경우에 서로 일치하게 해줌.
- 데이터 클래스: 캡슐화를 위해 데이터 클래스의 필드(변수)는 밖에서 접근 못 하게 private 등으로 설정해 주고 게터/세터로 바꿔주면서, 또한 꼭 필요한 경우가 아니라면 세터도 만들지 않는다. 데이터 클래스를 조작하는 코드를 클래스 내부로 옮길 수 있다면 차라리 그렇게 하는 것이 나음(일반 클래스 방식으로 변경).
- 상속 포기: 상속 구조에서 서브클래스가 슈퍼클래스로부터 상속받는 필드가 너무 많다면, 서브클래스에 필요 없는 슈퍼클래스의 멤버들은 새로운 서브클래스를 만들어서 거기에 담아 놓으면 됨. 슈퍼클래스의 인터페이스가 서브클래스에 너무 맞지 않는다면 아예 상속을 버리고 위임 방식(객체의 함수를 호출하는 방식)으로 변경.
- 주석: 많은 경우 주석은 함수 추출 및 함수명 개선으로 없앨 수 있음. 선행조건은 어서션으로 반영할 수 있음. 불확실한 부분이나 의도를 설명하는 부분에 코드를 달면 유용함.
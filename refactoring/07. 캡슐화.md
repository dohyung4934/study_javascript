# 07. 캡슐화

## 7.1 레코드 캡슐화하기

- 연산 없이 자료만 저장하는 '레코드' 자료구조는 사용하는 입장에서 무슨 필드가 있는지
  알기가 어렵고, 실제 정보가 저장된 방식을 외부로부터 숨긴 채 정보를 제공할 수 있고,
  불변성을 구현할 수 있다는 점이 있어서 레코드보다 클래스를 이용해서 데이터를 저장하는
  편이 나음.
- 클래스에 원본 데이터 객체를 저장하고 외부에서 게터로 객체를 가져갈 수 있게 하는 경우
  게터는 객체의 사본을 만들어서 반환하는 게 좋음.

## 7.2 컬렉션 캡슐화하기

- 게터를 만들어서 캡슐화를 할 때 데이터가 배열(컬렉션) 타입이라면 가급적
  배열을 그대로 반환하지 말고, 복사본을 만들어서 반환하거나
  아니면 꼭 필요한 배열 연산에 대해서 직접 함수를 만들어서 제공하는 편이 나음(불변성)

## 7.3 기본형을 객체로 바꾸기

- 데이터를 저장할 때, 단순히 화면에 출력하기 위한 용도가 아니라면
  문자열 타입보다 커스텀으로 클래스를 만들어서 사용하자
- ex 전화번호, 우선순위, 등급, 장소 등
- 클래스로 정보를 저장할 경우 데이터에 대한 연산을 한데 모을 수 있다는 장점

## 7.4 임시 변수를 질의 함수로 바꾸기

- 어떤 값을 얻기 위해서 중간에 임시 변수를 만들어서 사용하는 경우에,
  그 부분 로직을 별도의 함수로 빼내서 사용하면 코드 중복을 줄일 수 있고,
  클라이언트 함수의 매개변수 수도 줄일 수 있어 함수를 작은 단위로 쪼갤 때 유리함.

## 7.5 클래스 추출하기

- 클래스에 기능이 너무 많이 있으면 일부 기능을 별도 클래스로 추출하는 방법 고려
- 예를 들어 연락처 클래스에 전화번호 처리 관련 로직이 많이 있다면, 별도의 전화번호
  클래스를 만들고, 연락처 클래스에서 전화번호 클래스를 사용할 수 있음(전화번호 객체 참조)

## 7.6 클래스 인라인하기

- 7.5 클래스 추출하기와 반대
- 클래스가 더 이상 기능이 많지 않거나 굳이 별도의 클래스로 떨어져 있을 필요가 없을 때
- 먼저 위임 메서드를 타깃 클래스에 옮기고, 각각 테스트하고, 마지막으로 함수 로직을 실제 대응하는 필드로 옮김.

## 7.7 위임 숨기기

- 클라이언트가 서버 클래스(클라이언트의 반대 개념)에서 객체 참조를 통해 어떤 다른 객체의 메서드를 호출하는 구조일 때, 클라이언트가 서버의 인터페이스뿐 아니라 다른 객체의 인터페이스까지 알아야 하는 구조이기 때문에 결합도가 높아짐.
- 결합도를 낮추기 위해 서버 클래스에서 그 참조되는 객체의 메서드를 호출하는 위임 메서드를 만들어서 제공할 수 있음.

## 7.8 중개자 제거하기

- 7.7 위임 숨기기의 반대 기법
- 위임 숨기는 위임 함수들이 너무 많으면 서버 클래스의 인터페이스가 너무 복잡해질 수 있기 때문에, 이럴 때는 반대로 중개자(위임 함수)를 제거하고 바로 위임 객체를 노출하게끔 리팩터링할 수 있음.

## 7.9 알고리즘 교체하기

- 처리 알고리즘을 다른 것으로 교체하고 싶을 때
- 최대한 교체하고자 하는 알고리즘만 함수에 남기고 나머지 연관 없는 코드는 분리한 상태에서 작업하는 게 좋음.
